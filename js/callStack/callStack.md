# JS执行上下文和执行栈

## 理解JavaScript 中的执行上下文和执行栈

执行上下文是当前 JavaScript 代码被解析和执行时所在环境的抽象概念。

### 执行上下文的类型

执行上下文一共有三种

- 全局执行上下文：只有一个，在浏览器中就是window，在nodejs中就是global，this指向这个全局对象
- 函数执行上下文：无数个，每个函数调用时，都会产生一个函数执行上下文，
- eval函数执行上下文：`eval` 函数中的代码，很少用而且不建议使用。

#### 函数执行上下文

在函数上下文中，用活动对象(activation object, **AO**)来表示变量对象。

活动对象和变量对象的区别在于

- 1、变量对象（**VO**）是规范上或者是JS引擎上实现的，并不能在JS环境中直接访问。
- 2、当进入到一个执行上下文后，这个变量对象才会被**激活**，所以叫活动对象（**AO**），这时候活动对象上的各种属性才能被访问。

调用函数时，会为其创建一个**Arguments对象**，并自动初始化局部变量arguments，指代该Arguments对象。所有作为参数传入的值都会成为Arguments对象的数组元素。

##  

### 执行栈

执行栈，通过`栈`这个字我们就可以看出来，它是一个栈结构，所以具备LIFO的性质，其作用是为了存储在执行执行期间创建的所有的执行上下文

首次运行js代码时，会创建一个全局上下文，并且将其push到执行栈中，每次当函数调用时，都会push一个函数执行上下文进入执行栈中(push进执行栈的栈顶)，当函数执行完毕后，会将其pop出执行栈，控制权移交给当前执行栈的下一个执行上下文

```js
var a = 'Hello World!';

function first() {  
  console.log('Inside first function');  
  second();  
  console.log('Again inside first function');  
}

function second() {  
  console.log('Inside second function');  
}

first();  
console.log('Inside Global Execution Context');
```

我们来看上面这个例子，首先开始执行这段函数，js引擎会将全局执行上下文push进执行栈，其次执行first时，会将first这个函数执行上下文push进去，此时执行站内有两个执行上下文了，然后当前控制权在first执行上下文中，然后执行到second函数时，将second执行上下文入栈，然后将控制权交给second执行上下文，在second函数执行完后，second执行上下文出栈，然后控制权还给first执行上下文，此时first继续执行console，当first执行完毕后，first执行上下文pop出栈，然后继续执行console.log('Inside Global Execution Context');执行完毕后，全局上下文出栈

![image-20210408160315843](/Users/qitmac001126/Library/Application Support/typora-user-images/image-20210408160315843.png)

### 执行上下文的创建

执行上下文的创建分为两步，第一是创建阶段，第二是执行阶段

#### 创建阶段

1. 确定this的值
2. 词法组件被创建
3. 变量环境被创建

##### 确定this的值

- 全局上下文中，this指向window。而在nodejs环境中，this指向当前的module
- 函数执行上下文，this执行取决于函数的调用方式

##### 词法环境

词法环境由两部分组成

- 1、环境记录：存储变量和函数声明的实际位置
- 2、对外部环境的引用：可以访问其外部词法环境

词法环境有两种

- 1、全局环境：是一个没有外部词法环境的词法环境，其外部词法环境的引用为null，拥有一个全局对象(window)、其关联的属性和方法以及任何用户自定义的全局变量，this的值指向这个全局对象
- 2、函数环境：用户在函数中定义的变量被存储在环境记录中，包含了arguments对象，对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。

```js
GlobalExectionContext = {  // 全局执行上下文
  LexicalEnvironment: {    	  // 词法环境
    EnvironmentRecord: {   		// 环境记录
      Type: "Object",      		   // 全局环境
      // 标识符绑定在这里 
      outer: <null>  	   		   // 对外部环境的引用
  }  
}

FunctionExectionContext = { // 函数执行上下文
  LexicalEnvironment: {  	  // 词法环境
    EnvironmentRecord: {  		// 环境记录
      Type: "Declarative",  	   // 函数环境
      // 标识符绑定在这里 			  // 对外部环境的引用
      outer: <Global or outer function environment reference>  
  }  
}
```

##### 变量环境

变量环境实际上也是一个词法环境，因为它具有词法环境所具有的所有属性

在 ES6 中，**词法** 环境和 **变量** 环境的区别在于前者用于存储**函数声明和变量（ `let` 和 `const` ）**绑定，而后者仅用于存储**变量（ `var` ）**绑定。

变量提升的原因: 在创建阶段，函数声明存放在环境中，使用var声明的变量会被置为undefined，而使用let、const声明的变量会被置为**未初始化**

#### 执行阶段

此阶段，完成对所有变量的分配，最后执行代码。

如果 Javascript 引擎在源代码中声明的实际位置找不到 `let` 变量的值，那么将为其分配 `undefined` 值。

## JavaScript深入之执行上下文栈和变量对象

JS是单线程的语言，执行顺序肯定是顺序执行，但是JS 引擎并不是一行一行地分析和执行程序，而是一段一段地分析执行，会先进行编译阶段然后才是执行阶段。

### 变量和函数的声明提升

首先变量的声明和普通函数的声明是可以进行声明提升的，但是他们两个之间还是有优先级的，那就是函数的声明提升的优先级大于变量声明提升的优先级

```js
foo(); 
var foo = function() {
    console.log('foo1');
}

foo(); 

function foo() {
    console.log('foo2');
}

foo();
// foo2 foo1 foo2
```

从上面代码中，我们可以看出来函数的优先级大于变量，其实也可以说变量的优先级提升到当前作用域最顶层的，其次才是函数的变量提升

### 执行过程

上下文的执行过程分为两步进行处理

1. 进入执行上下文
2. 代码执行

#### 进入执行上下文

此时的变量对象会包括（如下顺序初始化）：

1.  函数所有的形参(函数上下文)： 没有实参，属性值设为undefined
2. 函数声明：如果变量对象已经存在相同名称的属性，则完全**替换**这个属性
3. 变量声明：如果变量名称跟已经声明的形参或函数相同，则变量声明**不会干扰**已经存在的这类属性。

```js
function foo(a) {
  var b = 2;
  function c() {}
  var d = function() {};

  b = 3;
}

foo(1);
```

对于上面的代码，这个时候的AO是

```js
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: undefined,
    c: reference to function c(){},
    d: undefined
}

```



#### 代码执行

这个阶段会顺序执行代码，修改变量对象的值，执行完成后AO如下

```js
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: 3,
    c: reference to function c(){},
    d: reference to FunctionExpression "d"
}

```

## JavaScript内存空间详解图

某些情况下，调用堆栈中函数调用的数量超出了调用堆栈的实际大小，浏览器会抛出一个错误终止运行。

### 栈

栈的数据结构就是**后进先出**(LIFO)

### 堆

堆数据结构是一种树状结构。它的存取数据的方式与书架和书非常相似。我们只需要知道书的名字就可以直接取出书了，并不需要把上面的书取出来。JSON格式的数据中，我们存储的`key-value`可以是无序的，因为顺序的不同并不影响我们的使用，我们只需要关心书的名字。

#### 堆的构成

### 队列

队列是一种**先进先出**的数据结构，这是事件循环的基础结构

### 变量的存放

我们知道内存中有堆、栈，那么变量应该存放在哪里呢

- 1、基本类型：基本类型一般都是存储在栈中的，因为这些类型的内存中分别占有固定的内存大小的空间，通过按值访问（但是闭包中的变量存储在堆内存中）
- 2、引用类型：引用类型一般都是存储在堆中的，因为这种类型的数据结构内存大小不固定，所以不能将其保存在栈中，但是因为内存大小是固定的，因此保存在堆中，而指向该对象的访问地址保存在栈中

在计算机的数据结构中，栈比堆的运算速度快，Object是一个复杂的结构且可以扩展：数组可扩充，对象可添加属性，都可以增删改查。将他们放在堆中是为了不影响栈的效率。而是通过引用的方式查找到堆中的实际对象再进行操作。所以查找引用类型值的时候先去**栈**查找再去**堆**查找。

### 内存空间管理

JavaScript的内存生命周期是

1. 分配你所需要的内存
2. 使用分配的内存读写
3. 不需要时将其释放、归还

## 内存回收

js有自动的垃圾回收机制，垃圾回收器每隔一段时间就会执行一次释放操作，找出那些不再继续使用的值，然后释放其占用的内存

- 局部变量和全局变量的销毁
  - 局部变量：局部作用域中，当函数执行完毕后，全局变量也没有存在的必要了，因此垃圾回收机制很容易做出判断并回收
  - 全局变量：全局变量什么时候需要自动释放内存空间很难判断，所以在开发中尽量**避免**使用全局变量。

- 以Google的V8引擎为例，V8引擎中所有的JS对象都是通过堆来进行内存分配的
  - **初始分配**：当声明变量并赋值时，V8引擎就会在堆内存中分配给这个变量。
  - **继续申请**：当已申请的内存不足以存储这个变量时，V8引擎就会继续申请内存，直到堆的大小达到了V8引擎的内存上限为止。
- V8引擎对堆内存中的JS对象进行分代管理
  - **新生代**：存活周期较短的JS对象，如临时变量、字符串等。
  - **老生代**：经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。

### 垃圾回收算法

垃圾回收算法其实就是如何判断内存已不再使用。常用的垃圾回收算法有两种

- 引用计数法(很少使用)
- 标记清除法

#### 引用计数法

引用计数法的定义标准很简单，就是看有没有变量指向当前的对象，如果没有，则表示当前对象没有引用，所以可以被回收了

引用计数法有一个很致命的缺陷就是在循环应用的时候，不能很好的判断是否应该回收当前变量

```js
function cycle() {
    var o1 = {};
    var o2 = {};
    o1.a = o2;
    o2.a = o1; 
    return "cycle reference!"
}

cycle();
```

上面的代码中执行cycle函数，o1和o2循环引用，尽管他们已不再使用，但是垃圾回收器不会对其进行回收，最终可能会导致内存泄露

#### 标记清除法

标记清除法将不再使用的对象定义为无法达到的对象

即从根部（在JS中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，**保留**。那些从根部出发无法触及到的对象被标记为**不再使用**，稍后进行回收。

##### 算法过程

1. 垃圾回收器创建一个roots列表，roots通常是代码中全局变量的引用。js中window是一个全局变量，被当成root。window对象总是存在因此垃圾回收器可以检查它和它的子对象是不是垃圾
2. 所有的roots被检查和被标记为激活，所有的子对象也被递归的检查。从 root 开始的所有对象如果是可达的，它就不被当作垃圾。
3. 所有未被标记的内存会被当做垃圾，收集器现在可以释放内存，归还给操作系统了

## 内存泄露

对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。 对于不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）

### 内存泄露识别方法

#### 1. 浏览器方法

- 打开浏览器，选择memory
- 在右侧的Select profiling type字段里面勾选 timeline
- 点击左上角的录制按钮。
- 在页面上进行各种操作，模拟用户的使用情况。
- 一段时间后，点击左上角的 stop 按钮，面板上就会显示这段时间的内存占用情况。

#### 2. 命令行方法

使用 `Node` 提供的 `process.memoryUsage` 方法。

```js
console.log(process.memoryUsage());

// 输出
{ 
  rss: 27709440,		// resident set size，所有内存占用，包括指令区和堆栈
  heapTotal: 5685248,   // "堆"占用的内存，包括用到的和没用到的
  heapUsed: 3449392,	// 用到的堆的部分
  external: 8772 		// V8 引擎内部的 C++ 对象占用的内存
}
```

### 引起内存泄露的四大原因

#### 1. 意外的全局变量

没有使用var、let、const声明的变量会变成一个全局变量

```js
function test() {
  a = 4; // ==> 等同于window.a = 4;
}
test()
```

另外一种就是由this指向引起的

```js
function test() {
  this.a = 4;// 此时的this指向window
}
test(); 
```



#### 2. 被遗忘的定时器或回调函数

```js
setInterval(() => {
  console.log(123)
}, 100)
```

此时没有手动清除定时器，一直会留在内存中，造成了内存泄露

#### 3. DOM的引用

如果将DOM节点保存在对象或者数组中，那么此时DOM节点有两个引用，一个是对象或者数组，一个是DOM树，将来需要将两个引用都要清除

#### 4. 闭包